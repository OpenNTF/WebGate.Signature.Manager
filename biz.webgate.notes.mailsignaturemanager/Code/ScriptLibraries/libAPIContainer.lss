'++LotusScript Development Environment:2:5:(Options):0:74
Option Public
Option Declare


'++LotusScript Development Environment:2:5:(Forward):0:1
Declare Class APIBaseClass
Declare Class LotusScriptRecompiler As APIBaseClass

'++LotusScript Development Environment:2:5:(Declarations):0:10
Const UPDATE_FORCE = &H0001

'Liste der API-Module:
Const modWin32 = "nnotes.dll" ' Windows/32 (Intel)
Const modLinux = "libnotes.so" ' UNIX (Solaris, Linux)
Const modMac = "NotesLib" ' Macintosh
Const modiSeries = "/qsys.lib/qnotes.lib/libnotes.svrpgm" ' OS/400, iSeries
'Const wAPIModule = "anotes.dll" ' Windows/32 (Alpha)
'Const wAPIModule = "Inotes.dll" ' OS/2v1, OS/2v2
'Const wAPIModule = "libnotes_r.a" ' UNIX (AIX)
'Const wAPIModule = "libnotes" ' OS/390
'Const wAPIModule = "libnotes.sl" ' UNIX (HP-UX)

'Windows
Declare Function w_OSPathNetConstruct Lib modWin32 Alias "OSPathNetConstruct" (ByVal portName As Integer, ByVal serverName As String, ByVal fileName As String, ByVal pathName As String) As Integer
Declare Function w_NSFDbOpen Lib modWin32 Alias "NSFDbOpen" (ByVal dbName As String, hDb As Long) As Integer
Declare Function w_NSFDbClose Lib modWin32 Alias "NSFDbClose" (ByVal hDb As Long) As Integer
Declare Function w_NSFNoteLSCompile Lib modWin32 Alias "NSFNoteLSCompile" (ByVal hDb As Long, ByVal hNote As Long, ByVal dwFlags As Long) As Integer
Declare Function w_NSFNoteSign Lib modWin32 Alias "NSFNoteSign" (ByVal hNote As Long) As Integer
Declare Function w_NSFNoteUpdate Lib modWin32 Alias "NSFNoteUpdate" (ByVal hNote As Long, ByVal flags As Integer) As Integer
Declare Function w_OSLoadString Lib modWin32 Alias "OSLoadString" (ByVal hModule As Long, ByVal stringCode As Integer, ByVal retBuffer As String, ByVal bufferLength As Integer) As Integer

'Linux
Declare Function l_OSPathNetConstruct Lib modLinux Alias "OSPathNetConstruct" (ByVal portName As Integer, ByVal serverName As String, ByVal fileName As String, ByVal pathName As String) As Integer
Declare Function l_NSFDbOpen Lib modLinux Alias "NSFDbOpen" (ByVal dbName As String, hDb As Long) As Integer
Declare Function l_NSFDbClose Lib modLinux Alias "NSFDbClose" (ByVal hDb As Long) As Integer
Declare Function l_NSFNoteLSCompile Lib modLinux Alias "NSFNoteLSCompile" (ByVal hDb As Long, ByVal hNote As Long, ByVal dwFlags As Long) As Integer
Declare Function l_NSFNoteSign Lib modLinux Alias "NSFNoteSign" (ByVal hNote As Long) As Integer
Declare Function l_NSFNoteUpdate Lib modLinux Alias "NSFNoteUpdate" (ByVal hNote As Long, ByVal flags As Integer) As Integer
Declare Function l_OSLoadString Lib modLinux Alias "OSLoadString" (ByVal hModule As Long, ByVal stringCode As Integer, ByVal retBuffer As String, ByVal bufferLength As Integer) As Integer

'iSeries, OS/400
Declare Function i_OSPathNetConstruct Lib modiSeries Alias "OSPathNetConstruct" (ByVal portName As Integer, ByVal serverName As String, ByVal fileName As String, ByVal pathName As String) As Integer
Declare Function i_NSFDbOpen Lib modiSeries Alias "NSFDbOpen" (ByVal dbName As String, hDb As Long) As Integer
Declare Function i_NSFDbClose Lib modiSeries Alias "NSFDbClose" (ByVal hDb As Long) As Integer
Declare Function i_NSFNoteLSCompile Lib modiSeries Alias "NSFNoteLSCompile" (ByVal hDb As Long, ByVal hNote As Long, ByVal dwFlags As Long) As Integer
Declare Function i_NSFNoteSign Lib modiSeries Alias "NSFNoteSign" (ByVal hNote As Long) As Integer
Declare Function i_NSFNoteUpdate Lib modiSeries Alias "NSFNoteUpdate" (ByVal hNote As Long, ByVal flags As Integer) As Integer
Declare Function i_OSLoadString Lib modiSeries Alias "OSLoadString" (ByVal hModule As Long, ByVal stringCode As Integer, ByVal retBuffer As String, ByVal bufferLength As Integer) As Integer

Class APIBaseClass
	Private db As NotesDatabase
	Private hDb As Long
	Private lastError As String
	
	Public Sub New ()
		'** Nothing To instantiate In the Base Class
	End Sub
	
	Public Sub Delete ()
		Call CloseDatabase()
	End Sub
	
	Public Function OpenDatabase (db As NotesDatabase) As Integer
		On Error GoTo processError
		
		Dim sess As New NotesSession
		
		If (hDb > 0) Then
			Call CloseDatabase()
		End If
		
		'** Reset the internals
		Set Me.db = db
		lastError = ""
		
		Dim pathName As String*256
		Dim result As Integer
		
		If sess.Platform = "Windows/32" Then
			'** create a proper network path Name With OSPathNetConstruct
			Call w_OSPathNetConstruct(0, db.Server, db.FilePath, pathName)
			
			'** Open the database And Get a handle With NSFDbOpen
			result = w_NSFDbOpen(pathName, hDb)
		ElseIf sess.Platform = "UNIX" Then
			Call l_OSPathNetConstruct(0, db.Server, db.FilePath, pathName)
			
			result = l_NSFDbOpen(pathName, hDb)
		ElseIf sess.Platform = "OS/400" Then			
			Call i_OSPathNetConstruct(0, db.Server, db.FilePath, pathName)
			
			result = i_NSFDbOpen(pathName, hDb)
		End If
		
		If result = 0 Then
			OpenDatabase = True
		Else
			Call SetLastError("Cannot Open database " & db.FilePath & " On server " & db.Server, result)
		End If
	
		Exit Function
	
	processError:
		Call SetLastError("Error opening database", 0)
		Exit Function
	
	End Function
	
	Public Sub CloseDatabase ()
		On Error Resume Next
		
		Dim sess As New NotesSession
		
		If (hDb > 0) Then
			If sess.Platform = "Windows/32" Then
				Call w_NSFDbClose(hDb)
			ElseIf sess.Platform = "UNIX" Then
				Call l_NSFDbClose(hDb)
			ElseIf sess.Platform = "OS/400" Then
				Call i_NSFDbClose(hDb)
			End If			
		End If
		
		Set db = Nothing
		hDb = 0
		lastError = ""
	End Sub
	
	Private Function SetLastError (errText As String, apiResultCode As Integer) As String
		If (apiResultCode <> 0) Then
			LastError = "API Error " & apiResultCode & ": " & GetAPIError(apiResultCode)
		ElseIf (Err > 0) Then
			LastError = "Notes Error " & Err & ": " & Error$
		Else
			LastError = ""
		End If
		
		If (Len(errText) > 0) Then
			LastError = errText & ". " & LastError
		End If
	End Function
	
	Public Function GetLastError () As String
		GetLastError = LastError
	End Function
	
	Public Function GetAPIError (errorCode As Integer) As String
		Dim sess As New NotesSession
		Dim errorString As String*256
		Dim returnErrorString As String
		Dim resultStringLength As Long
		Dim errorCodeTranslated As Integer
		
		Const ERR_MASK = &H3fff
		Const PKG_MASK = &H3f00
		Const ERRNUM_MASK = &H00ff
		
		'** mask off the top 2 bits of the errorCode that was returned; this Is
		'** what the Err macro In the API does
		errorCodeTranslated = (errorCode And ERR_MASK)
		
		'** Get the Error code translation using the OSLoadString API Function
		If sess.Platform = "Windows/32" Then
			resultStringLength = w_OSLoadString(0, errorCodeTranslated, errorString, Len(errorString) - 1)
		ElseIf sess.Platform = "UNIX" Then
			resultStringLength = l_OSLoadString(0, errorCodeTranslated, errorString, Len(errorString) - 1)
		ElseIf sess.Platform = "OS/400" Then
			resultStringLength = i_OSLoadString(0, errorCodeTranslated, errorString, Len(errorString) - 1)
		End If
		
		
		'** strip off the null-termination On the String before you Return it
		If (InStr(errorString, Chr(0)) > 0) Then
			returnErrorString = Left$(errorString, InStr(errorString, Chr(0)) - 1)
		Else
			returnErrorString = errorString
		End If
		
		GetAPIError = returnErrorString
	
	End Function
End Class

Class LotusScriptRecompiler As APIBaseClass
	Public Function RecompileLSByNoteID (noteID As String) As Integer
		On Error GoTo processError
		
		If (db Is Nothing) Then
			Call SetLastError("Database Is Not open", 0)
			Exit Function
		End If
		
		Dim doc As NotesDocument
		Set doc = db.GetDocumentByID(noteID)
		RecompileLSByNoteID = RecompileLS(doc)
		Exit Function
	
	processError:
		Call SetLastError("Error recompiling LotusScript For " & noteID, 0)
	Exit Function
	
	End Function
	
	Public Function RecompileLSByUNID (unid As String) As Integer
		On Error GoTo processError
		
		If (db Is Nothing) Then
			Call SetLastError("Database Is Not open", 0)
			Exit Function
		End If
		
		Dim doc As NotesDocument
		Set doc = db.GetDocumentByUNID(unid)
		RecompileLSByUNID = RecompileLS(doc)
		Exit Function
	
	processError:
		Call SetLastError("Error recompiling LotusScript For " & unid, 0)
	Exit Function
	
	End Function
	
	Public Function RecompileLS (doc As NotesDocument) As Integer
		On Error GoTo processError
		
		Dim sess As New NotesSession
		Dim hNote As Long
		Dim unid As String
		Dim result As Integer
		
		If (hDb = 0) Then
			Call SetLastError("Database Is Not open", 0)
			Exit Function
		ElseIf (doc Is Nothing) Then
			Call SetLastError("Invalid document reference", 0)
			Exit Function
		End If
		
		'** super-special-secret way of getting an API handle To a NotesDocument
		hNote = doc.Handle
		unid = doc.UniversalID
		
		'** first, we compile the note
		If sess.Platform = "Windows/32" Then
			result = w_NSFNoteLSCompile(hDb, hNote, 0)
		ElseIf sess.Platform = "UNIX" Then
			result = l_NSFNoteLSCompile(hDb, hNote, 0)
		ElseIf sess.Platform = "OS/400" Then
			result = i_NSFNoteLSCompile(hDb, hNote, 0)
		End If
		
		If (result <> 0) Then
			Call SetLastError("Cannot compile LotusScript For " & GetTitle(doc), result)
			Exit Function
		End If
		
		'** Then we sign it
		If sess.Platform = "Windows/32" Then
			result = w_NSFNoteSign(hNote)
		ElseIf sess.Platform = "UNIX" Then
			result = l_NSFNoteSign(hNote)
		ElseIf sess.Platform = "OS/400" Then
			result = i_NSFNoteSign(hNote)
		End If
		
		If (result <> 0) Then
			Call SetLastError("Cannot sign " & GetTitle(doc), result)
			Exit Function
		End If
		
		'** Then we save it
		If sess.Platform = "Windows/32" Then
			result = w_NSFNoteUpdate(hNote, UPDATE_FORCE)
		ElseIf sess.Platform = "UNIX" Then
			result = l_NSFNoteUpdate(hNote, UPDATE_FORCE)
		ElseIf sess.Platform = "OS/400" Then
			result = i_NSFNoteUpdate(hNote, UPDATE_FORCE)
		End If
				
		If (result <> 0) Then
			Call SetLastError("Cannot save " & GetTitle(doc), result)
			Exit Function
		End If
		
		'** update the in-memory reference To the object
		Delete doc
		Set doc = db.GetDocumentByUNID(unid)
		
		'** a little trick To avoid this message On recompiled forms:
		'** This document has been altered since the last Time it was signed! Intentional tampering may have occurred.
		Call doc.Sign()
		Call doc.Save(True, False)
		
		lastError = ""
		RecompileLS = True
		Exit Function
		
	processError:
		Call SetLastError("Error recompiling LotusScript For " & GetTitle(doc), 0)
		Exit Function
	
	End Function
	
	Public Function GetTitle (doc As NotesDocument) As String
		On Error Resume Next
		If (doc Is Nothing) Then
			Exit Function
		End If

		Dim title As String
		title = doc.~$Title(0)
		If (InStr(title, "|") > 0) Then
			title = StrLeft(title, "|")
		End If

		If (title = "") Then
			title = "(untitled)"
		End If

		GetTitle = |"| & title & |"|
		
	End Function
End Class